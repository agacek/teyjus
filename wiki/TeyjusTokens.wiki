#summary Tokens in Teyjus
= Characterization of Tokens in Teyjus =

We describe below the rules for recognizing tokens in the different relevant categories. Two points are relevant to mention prior to this description. First, as is standard, the principle of longest match is used in tokenization. The Teyjus lexical analyzer is in fact automatically generated by the _OCaml_ equivalent of _flex_, based on a regular grammar presentation of the tokens and token categories below. Second, a far fewer set of characters are treated as token separators than is usual. In particular, only the characters identified as punctuation symbols are interpreted in this manner over and above 'white space' characters. To take a specific example, a sequence such as _X+Y_ is interpreted as a token as opposed to a sequence of three tokens.


== Keywords ==

The following sequences of characters are recognized as tokens with a special meaning within Teyjus.
 	
{{{
module     end          import     accumulate     accum_sig     local
type       closed       sig        use_sig        exportdef     infix         
kind       useonly      infixl     typeabbrev     infixr        prefix      
prefixr    postfix    localkind    postfixl       :-            \          
->         !
}}}

== Other Special Tokens in Teyjus ==

The following tokens are ones that, in addition to the keywords and punctuation symbols, cannot be redefined by user programs. Some of these symbols---in particular, the symbols _pi_, _sigma_, _;_, _&_, _=>_, _=_, _::_ and _nil_---are constants and are like other identifiers except for the 'no redefinition' clause. The remaining symbols are overloaded and so are treated in a special way by the parser. Finally, some symbols, in particular _::_ and _nil_, receive a special treatment at the abstract machine level.
 	
{{{
pi         sigma        ,          ;           &          =>         
+          -            *          /           ::         =
~          <            >          =<          >=         nil
}}}

== Punctuations ==

The following symbols serve as delimiters, grouping symbols, etc. Notice that comma appears in the list of pseudo keywords as well; usage is determined by context.
 	
{{{
.          ,            (          )          :         [          
]          | 
}}}

== Identifiers and Variable Names ==

Any contiguous sequence of alphanumeric or sign characters different from the punctuation characters (i.e. any of the characters +-*/\^<>=`'~?@#$&!_~) that begins with something other than a digit or the sequence /* constitutes a name. A name that begins with anything other than the underscore character may be used as that of a variable bound by an abstraction. Names other than those that begin with the underscore (_) character or an uppercase letter and those included in the special tokens category may be identified as constants through type declarations or sorts or type constructors through kind declarations. Such names are also interpreted as those of (local, undeclared) constants if they are used in clauses without a previous type declaration and they are not bound by enclosing abstractions. A name that begins with the underscore character or with an uppercase letter and that is not bound by an abstraction is considered to be that of a free (implicitly existentially quantified) variable.

Three points should be noted with regard to this definition. First, as already observed and unlike in most other languages, certain characters (like -, *, etc) are not treated as token separators in addition to being tokens. Thus, X-Y is a single token and not a sequence of three tokens. Second, some token sequences such as => and -> appear to be ambiguous, qualifying to be either keywords or names. This ambiguity is resolved by deeming the keyword interpretation to take precedence in all such cases. Finally, some names, such as pi and ::, are treated as special (overloaded or predefined) tokens and these cannot be reinterpreted through type declarations. 