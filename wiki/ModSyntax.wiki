#summary Syntax of Modules

= The Structure of Source Code for a Module =

We describe here the structure of declarations constituting the source code for a module that is contained in a file called <modname>.mod. As already explained, this source code file goes hand-in-hand with the signature file for the module and requires the latter to be used in its interpretation.

The Teyjus parser for the source code file consists of a part automatically generated by the _OCaml_ parser generator from a context-free grammar and a post processor that manipulates the (pre) abstract syntax structures generated by the automatically constructed parser. The post processing phase is needed to handle information such as arities of type constructors and operator fixities and precedence that is also gleaned through the parse. The grammar below represents the effect of the combined processing and should not be confused with the one that forms the input to the parser generator.

== A BNF Specification of Module Syntax ==

The rules below describe the syntax of the declarations that may appear in a module file. These grammar rules build on the ones already presented while explaining the syntax of signatures in [SigSyntax A BNF Specification of Signature Syntax]. Thus, to understand this grammar, it may be necessary to consult also the grammar for signatures.
 	
{{{
<Module>        ::=  <ModHeader> <ModPreamble> <ModBody> <ModEnd>

<ModHeader>     ::=  'module' <NameToken> '.'

<ModEnd>        ::=  '$'                        % $ stands for eof
                   | 'end' 

<ModPreamble>   ::=  <Empty>
                   | 'import' <NameTokens> '.' <ModPreamble>
                   | 'accumulate' <NameTokens> '.' <ModPreamble>
                   | 'accum_sig' <NameTokens> '.' <ModPreamble>
                   | 'use_sig' <NameTokens> '.' <ModPreamble>

<ModBody>       ::=  <Empty> 
                   | <ModSignDecl> <ModBody>
                   | <ModClause> <ModBody>

<ModSignDecl>   ::=  <Sign-Decl>
                   | 'local' <Ids> '.'
                   | 'local' <Ids> <Type> '.'
                   | 'localkind' <Ids> '.'
                   | 'localkind' <Ids> <Kind> '.'
                   | 'closed' <Ids> '.'
                   | 'closed' <Ids> <Type> '.'

<ModClause>     ::=  <Clause> '.'

<Clause>        ::=  <Atom>
                   | <Clause> ':-' <Goal>
                   | <Goal> '=>' <Clause>
                   | <Clause> ',' <Clause>
                   | <Clause> '&' <Clause>
                   | <PiId> <TypedId> '\' <Clause>
                   | <PiId> <CTerm>
                   | '(' <Clause> ')'

<Goal>          ::=  '!'
                   | <PiId> <Term>
                   | <PiId> <TypedId> '\' <Goal>
                   | <SigmaId> <Term>
                   | <SigmaId> <TypedId> '\' <Goal>
                   | <Goal> ';' <Goal>
                   | <Goal> ',' <Goal>
                   | <Goal> '&' <Goal>
                   | <Clause> '=>' <Goal>
                   | <Atom>
                   | <FlexAtom>
                   | '(' <Goal> ')'


<Atom>          ::=  <Term>    { the type of the term must be boolean
                                 and its main functor must be a constant
                                 or a variable bound by an enclosing
                                 essential universal quantifier }

<FlexAtom>      ::=  <TypedVar>
                   | <FlexAtom> <AppTerm>
                   | '(' <FlexAtom> ')'


<CTerm>         ::=  <Term>    { The main functor of the term must be a 
                                 constant or a variable bound by an
                                 enclosing essential universal 
                                 quantifier }

<Term>          ::=  <Term> <TypedCIdent> <Term>   
                   | <Term> <TypedCIdent>          
                   | <TypedCIdent> <Term>          
                   | <Term> <Term>
                   | <TypedId> '\' <Term>
                   | '[' ']'                    % Prolog list notation
                  | '[' TermList ']'            % Prolog list notation
                   | '[' TermList '|' Term ']'  % Prolog list notation
                   | <TypedCIdent>
                   | <TypedVar> 
                   | <TypedId>
                   | '(' <Term> ')'

<TermList>      ::=  <Term>
                   | <Term> ',' <TermList>

<PiId>          ::=  'pi'
                   | 'pi' ':' <Type>
                   | '(' <PiId> ')'

<SigmaId>       ::=  'sigma'
                   | 'sigma' ':' <Type>
                   | '(' <SigmaId> ')'

<TypedId>       ::=  <AbsToken>
                   | <AbsToken> ':' <Type>
                   | '(' <TypedId> ')'

<TypedVar>      ::=  <VIdent>
                   | <VIdent> ':' <Type>
                   | '(' <TypedVar> ')'

<TypedCIdent>   ::=  <SpecialOp>
                   | <Id>
                   | <Id> ':' <Type>
                   | '(' <TypedCIdent> ')'

<SpecialOp>     ::=  { A pseudo keyword corresponding to one of the 
                        overloaded operators }

<AbsToken>      ::=  { A <NameToken> that does not begin with _ }

<VIdent>        ::=  { A Teyjus token that begins with an uppercase
                        letter or _ and that is not the variable bound
                        by an enclosing abstraction }
}}}

== Commentary on Module Syntax ==

The module declaration must satisfy certain properties in addition to adhering to the syntax rules:

    * Each module is expected to be presented in a distinct file. This file must have the name _<modname>.mod_ where _<modname>_ is the name of the relevant module and the associated signature. This name should also coincide with the name indicated in the module header, generated by the rule for _<ModHeader>_.

    * Accumulate, import, accumsig and usesig declarations are those appearing in the module preamble (i.e. generated by the rule for _<ModPreamble>_) and beginning with the tokens _accumulate_, _import_, _accum`_`sig_ and _use`_`sig_ respectively. The accumsig and usesig declarations have a role in module declarations that is similar to the one they have in signature declarations. Accumulates and imports have been explained informally in the section the [ProgramStructure structure of programs] in _Teyjus_. This informal description is further bolstered by the presentation elsewhere of the rules for [SigMatching matching signatures with modules and for certifying module interactions].

    * Local constant and local kind declarations are those in the category <ModSignDecl> that begin with the tokens local and localkind respectively. These declarations identify constants and kinds that are to be treated as being scoped within the module in which they appear and those that are imported and accumulated by this module.

    * Closed constant declarations are those in the category <ModSignDecl> that begin with the token closed. Every closed constant must be of predicate type. From an outward perspective, these constants behave like exportdef constants: their definitions are exported from the module in question and the cannot be changed in the importing or accumulating context. From an inward perspective, these constants are ones for which an assurance can be given of fixity of code. Thus, they should either be defined as useonly or they should not be globals in imported modules reachable through some chain of accumulates.

    * There is some redundancy in module syntax. In particular, exportdef, useonly, local and localkind declarations may be left out; the former two must also appear in the explicit signature file and locals can be taken to be the complement of the sorts, type constructors and constants defined in the explicit signature file. However, they are included in the syntax of modules to permit a preprocessing phase that calculates the explicit signature. (This is not the preferred situation though; signature files are intended to be useful in the certification of module interactions and not an obstacle to be surmounted in whichever way possible.)

    * The name of a predicate defined by a clause that appears at the top level in the module or in the antecedent of an implication goal must not be identical to that of a logical symbol or a useonly predicate. It must not also be identical to that of a built-in predicate unless the predicate name has been redefined through a type declaration.

    * There must be at most one arity and type associated with any given Id. There might be multiple declarations for this Id but all must agree eventually.

    * In the form
{{{
             <Term> <TypedCIdent> <Term> 
}}}

      that appears in the rules for <Term>, the identifier must have been declared as an infix operator. Similarly, in the form     	
{{{
             <Term> <TypedCIdent>
}}}

      that appears in the rule for <Term>, the identifier must have been declared as a postfix operator and in the form    	
{{{
             <TypedCIdent> <Term>
}}}

      the identifier should have been declared as a prefix operator. The rule for <Term> is obviously ambiguous as written. Disambiguation is to be affected using the precedence and associativity of the relevant operators. In this context, it is also to be noted that abstraction and application are treated like (infix) operators, that application is left associative and has higher precedence than all other operators and abstraction is right associative and has lower precedence than all other operators.

    * The comma (',') token is overloaded in many different ways. One place where this overloading causes ambiguity is in terms embedded within Prolog style lists: here it can either be interpreted as the (infix) conjunction operator or as a list separator. The intended disambiguation device in this context is the following: if both the left and the right hand side of the comma operator has the ground type o, then this is interpreted as the symbol for conjunction, otherwise it is understood to be the list separator. Of course, the reading of comma as the conjunction operator can be forced by surrounding the expression within parentheses. For example, in
{{{
           [ p,(q,r),s]
}}}

      the middle comma is forced to be interpreted as conjunction. In the other direction, if p, q and r are of predicate type, we may want to construct a list that has these three as elements. This cannot be forced using the Prolog-style list notation; the list  	
{{{
           [p, q, r]
}}}

      will only be read as a singleton list. However, to depict such a list, we can use :: and nil based representation instead.

    * The arithmetic operators like +, `*` and - and the comparison operators <, =<, > and >= are also overloaded. Teyjus requires that one of the operands of these operators must be recognizably of ground type. If this is not the case, an error is signalled. This requirement is a little stringent: particular subexpressions may not have this property but, in the end, it may still be possible to determine a specific type for the overall expression. This treatment will have to be rethought in a new version of the system

    * There are the usual typing restrictions on well-formedness.

    * The constants representing implication are not permitted to appear embedded inside terms.

    * Signature files should exist for accumulated and imported modules and accumulated signatures. Source code files should exist for accumulated modules.

    * We can calculate a signature from the source code for a module by taking the type, kind and fixity declarations in a module, adding to these the accumulated signatures and signatures of accumulated and imported modules and removing all the declarations corresponding to local constants and localkind types. The type association for all the constants and the arity association for all the kinds in this signature that are also defined in the signature file for the module must be identical. (All the objects in this calculated signature that do not also appear in the explicitly defined signature are interpreted as local or localkind objects.)

    * All exportdef and useonly declarations in the calculated signature must be for global constants and must also appear in the explicit signature. All fixity declarations for global constants in the calculated signature must also appear in the explicit signature. A global constant that is defined to be closed (in the module source) should be exportdef (in the explicit signature).

    * Tokens that begin with uppercase letters are to be interpreted as variables. Such variables may be bound or free depending on whether or not they are captured by an enclosing abstraction. Notice in contrast that tokens that begin with `_` can only be free variables. Notice also that bound variables may, in addition, begin with lower case letters or sign characters, much like constant tokens. Free variables that appear in clauses are to be understood as being implicitly universally qualified at the head of the clause. All occurrences of a (bound or free) variable in a clause must have the same type.

    * In the rule for an <Atom>, the head is permitted to be an essentially universally quantified variable. In determining the interpretation of a quantifier, the assumption is that a Clause appears in a negative context.

    * Every sort and type constructor that is used in the type declarations and clauses in a module must be explicitly declared. While this practice is not encouraged, undeclared constants may be used in the clauses in a module. Types are to be inferred for these constants in these cases based on usage. The convention to be used in this inferring such types is that every usage of such a constant is at a type identical to its implicitly declared type and, further, this implicitly declared type is the most general type consistent with all the usages of the constant and this convention. The Teyjus compiler is designed to display the inferred types of these constants in the form of a warning relative to each module that it processes.

    * A chain of imports or accumulates from a given module must not lead back to the same module. This violation of syntax for imported modules cannot be detected at compile time without violating the philosophy of separate compilation, but it will be detected at load time. 