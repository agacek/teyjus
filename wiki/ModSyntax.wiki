#summary Syntax of Modules

= The Structure of Source Code for a Module =

We describe here the structure of declarations constituting the source code for a module that is contained in a file called <modname>.mod. As already explained, this source code file goes hand-in-hand with the signature file for the module and requires the latter to be used in its interpretation.

The Teyjus parser for the source code file consists of a part automatically generated by the _OCaml_ parser generator from a context-free grammar and a post processor that manipulates the (pre) abstract syntax structures generated by the automatically constructed parser. The post processing phase is needed to handle information such as arities of type constructors and operator fixities and precedence that is also gleaned through the parse. The grammar below represents the effect of the combined processing and should not be confused with the one that forms the input to the parser generator.

== A BNF Specification of Module Syntax ==

The rules below describe the syntax of the declarations that may appear in a module file. These grammar rules build on the ones already presented while explaining the syntax of signatures in [SigSyntax A BNF Specification of Signature Syntax]. Thus, to understand this grammar, it may be necessary to consult also the grammar for signatures.
 	
{{{
<Module>        ::=  <ModHeader> <ModPreamble> <ModBody> <ModEnd>

<ModHeader>     ::=  'module' <NameToken> '.'

<ModEnd>        ::=  '$'                        % $ stands for eof
                   | 'end' 

<ModPreamble>   ::=  <Empty>
                   | 'import' <NameTokens> '.' <ModPreamble>
                   | 'accumulate' <NameTokens> '.' <ModPreamble>
                   | 'accum_sig' <NameTokens> '.' <ModPreamble>

<ModBody>       ::=  <Empty> 
                   | <ModSignDecl> <ModBody>
                   | <ModClause> <ModBody>

<ModSignDecl>   ::=  <Sign-Decl>
                   | 'local' <Ids> '.'
                   | 'local' <Ids> <Type> '.'
                   | 'localkind' <Ids> '.'
                   | 'localkind' <Ids> <Kind> '.'
                   | 'closed' <Ids> '.'
                   | 'closed' <Ids> <Type> '.'

<ModClause>     ::=  <Clause> '.'

<Clause>        ::=  <Atom>
                   | <Clause> ':-' <Goal>
                   | <Goal> '=>' <Clause>
                   | <Clause> ',' <Clause>
                   | <Clause> '&' <Clause>
                   | <PiId> <TypedId> '\' <Clause>
                   | <PiId> <CTerm>
                   | '(' <Clause> ')'

<Goal>          ::=  '!'
                   | <PiId> <Term>
                   | <PiId> <TypedId> '\' <Goal>
                   | <SigmaId> <Term>
                   | <SigmaId> <TypedId> '\' <Goal>
                   | <Goal> ';' <Goal>
                   | <Goal> ',' <Goal>
                   | <Goal> '&' <Goal>
                   | <Clause> '=>' <Goal>
                   | <Atom>
                   | <FlexAtom>
                   | '(' <Goal> ')'


<Atom>          ::=  <Term>    { the type of the term must be boolean
                                 and its main functor must be a constant
                                 or a variable bound by an enclosing
                                 essential universal quantifier }

<FlexAtom>      ::=  <TypedVar>
                   | <FlexAtom> <AppTerm>
                   | '(' <FlexAtom> ')'


<CTerm>         ::=  <Term>    { The main functor of the term must be a 
                                 constant or a variable bound by an
                                 enclosing essential universal 
                                 quantifier }

<Term>          ::=  <Term> <TypedCIdent> <Term>   
                   | <Term> <TypedCIdent>          
                   | <TypedCIdent> <Term>          
                   | <Term> <Term>
                   | <TypedId> '\' <Term>
                   | '[' ']'                    % Prolog list notation
                   | '[' TermList '|' Term ']'  % Prolog list notation
                   | <TypedCIdent>
                   | <TypedVar> 
                   | <TypedId>
                   | '(' <Term> ')'

<TermList>      ::=  <Term>
                   | <Term> ',' <TermList>

<PiId>          ::=  'pi'
                   | 'pi' ':' <Type>
                   | '(' <PiId> ')'

<SigmaId>       ::=  'sigma'
                   | 'sigma' ':' <Type>
                   | '(' <SigmaId> ')'

<TypedId>       ::=  <AbsToken>
                   | <AbsToken> ':' <Type>
                   | '(' <TypedId> ')'

<TypedVar>      ::=  <VIdent>
                   | <VIdent> ':' <Type>
                   | '(' <TypedVar> ')'

<TypedCIdent>   ::=  <SpecialOp>
                   | <Id>
                   | <Id> ':' <Type>
                   | '(' <TypedCIdent> ')'

<SpecialOp>     ::=  { A pseudo keyword corresponding to one of the 
                        overloaded operators }

<AbsToken>      ::=  { A <NameToken> that does not begin with _ }

<VIdent>        ::=  { A Teyjus token that begins with an uppercase
                        letter or _ and that is not the variable bound
                        by an enclosing abstraction }
}}}