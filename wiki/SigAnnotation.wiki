#summary Explains the purpose of predicate annotations

= Using Signatures to Certify Module Interactions =

Part of the process of certifying module interactions involves checking for compatibility between symbols that are global to an imported module and the definitions of these symbols in the importing module or in the signatures of sibling imported modules. This aspect is covered under the topic of matching a module with its signature. The other part of the process concerns ensuring that restrictions imposed by closed, exportdef and useonly declarations are satisfied. This is done as follows:

_Closed Declarations--Inwards_

    We assume that we are given a list of closed predicates at the outset; these predicates are ones defined to be closed in some module within whose accumulate structure the present one appears embedded. We prune this list first by eliminating all the predicates that are either not global in the present module or are defined to be useonly. We then add to the list all the predicates defined to be closed within the present module. Modules accumulated into the present context are then to be processed in the same fashion as the one being described, except that the incoming list of closed predicates is the newly derived one. With regard to each imported module, the requirement is that if any of the predicates in the newly derived list is global to it, then it is also defined to be useonly.

_Exportdef Declarations_

    One aspect to check is the compatibility of the `parent' module with those imported or accumulated by it. For this purpose, we (conceptually) collect all the exportdef predicates from the signatures of the imported or accumulated modules. We then check that the resulting list consists of only non-global constants or of global predicates that are also of the exportdef kind in the parent module. Further, none of the predicates in this list should have defining clauses in the parent module.

    The other aspect to check is compatibility between sibling imported and accumulated modules. For this purpose, it is necessary to determine that the exportdef declaration of each predicate in one module is complemented by a useonly declaration for that predicate in a sibling module if that predicate is global there.

_Closed Declarations--Outwards_

    The role of closed declarations from an outwards perspective is identical to that of exportdef declarations and processing relevant to it therefore follows the lines described in the preceding item.

_Useonly Declarations_

    Within the main module and each accumulated module, we check that there are no clauses defining useonly predicates as described in the section on matching a module with its signature. Then for each accumulated/imported module and useonly constant we check that the constant is either not global in that module or is defined to be useonly in it.