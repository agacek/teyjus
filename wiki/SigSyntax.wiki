#summary Syntax of Signatures

= The Structure of a Signature File =

The Teyjus parser for signatures is a combination of a "pre-parser" automatically generated by the _OCaml_ parser generator from a context-free grammar and a post processor that manipulates the pre-abstract syntax structures generated from the grammar. The post processing phase is needed to handle information such as the arities of type constructors that is also gleaned through the (pre-)parse. The grammar below describes a syntax that is the sum total of these two phases. It is presented in this way to explicate signature syntax to the user of a system and is not to be confused with the context-free grammar description that is given to the parser generator.

== A BNF Specification of Signature Syntax ==
 	
{{{
<Signature>    ::=   <SigHeader> <SigPreamble> <Sign-Decls> <SigEnd>

<SigHeader>    ::=   'sig' <NameToken> '.'

<SigEnd>       ::=   'end' | '$'                 % $ stands for eof

<SigPreamble>  ::=   <Empty>
                   | accum_sig <NameTokens> '.' <SigPreamble>
                   | use_sig <NameTokens> '.' <SigPreamble>

<NameTokens>   ::=   <NameToken>
                   | <NameToken> ',' <NameTokens>

<Sign-Decls>   ::=   <Empty>
                   | <Sign-Decl> <Sign-Decls>

<Sign-Decl>    ::=   'kind'  <Ids>  <Kind> '.'
                   | 'typeabbrev' <AbbrForm> <Type> '.'
                   | 'type'  <Ids>  <Type> '.'
                   | <Fixity> <Ids> <SmallInt> '.'
                   | 'exportdef' <Ids> '.' 
                   | 'exportdef' <Ids> <Type> '.'
                   | 'useonly' <Ids> '.' 
                   | 'useonly' <Ids> <Type> '.'

<Ids>          ::=   <Id>
                   | <Id> ',' <Ids>

<Kind>         ::=   'type'
                   | 'type' '->' <Kind>

<AbbrForm>     ::=   <Id>
                   | '(' <Id> <NamedVarList> ')'
                   | '(' <AbbrForm> ')'

<NamedVarList> ::=   <NamedVar>
                   | <NamedVar> <NamedVarList>   

<Type>         ::=   <CType> '->' <Type>
                   | <CType>

<CType>        ::=   <NameToken>
                   | <TyCIdent> <CTypes>
                   | '(' <Type> ')'

<TyCIdent>     ::= <Id>

<CTypes>       ::=   <CType>
                   | <CType> <CTypes>

<Fixity>       ::=   'infixl' | 'infixr' | 'infix'
                   | 'prefix' | 'prefixr'
                   | 'postfix' | 'postfixl'

<NameToken>    ::=  { Any Teyjus token distinct from keywords,
                        pseudo-keywords, integer, string and real
                        literals }

<Id>           ::=  { Like NameToken, except that the token should 
                       also begin with something different from an 
                       uppercase letter and _ }

<NamedVar>     ::=  { Any named token that begins with an 
                      uppercase letter }
                       
<SmallInt>     ::=  { Integer value between 0 and 255; i.e. unsigned 
                     one byte number }

<Empty>        ::=  { empty token sequence }
}}}



== Commentary on Signature Syntax ==

The declarations in a signature file must satisfy certain properties in addition to being derivable from the grammar rules:

    * Each signature is expected to be presented in a distinct file. This file must have the name <modname>.sig where <modname> is the name of the relevant module and signature. This name should also coincide with the name indicated in the signature header, generated by the rule for <SigHeader>.

    * The intended effect of accum`_`sig declarations is to include the declarations in the named signatures in the signature being generated from the text in the present file. Thus, accum`_`sig functions in a manner similar to #include in C. The possible interactions between sibling accumulated signatures and the accumulating signature are discussed further below.

    * Kind declarations are those expressions in the category <Sign-Decl> that begin with the token kind. The purpose of these declarations is to identify sorts and type constructors that may be used in determining types for constants and variables. Thus a declaration of the form
 {{{      	
           kind  foo  type -> ... -> type
}}}

   with n+1 occurrences of type identifies foo as a type constructor of arity n. (If n is 0 the object identified is a sort.) Note that there are restrictions built into the grammar rules on the syntax of tokens that can be identified as sorts and type constructors.

    * Type abbreviation declarations are those expressions in the category <Sign-Decl> that begin with the token typeabbrev. The purpose of these declarations is to identify names that can be used as shorthands in type expressions. These names can also be parameterized. For example, a declaration of the form 
{{{
          typeabbrev   (bar A)   list A -> list A
}}}
 
     allows (bar int) to be used as an abbreviation for the expression list int -> list int in the type expressions described below. There is a restriction on the type expressions that figure in such a declaration: any variable that is used in them must have been identified as a "parameter" of the name that is being identified as an abbreviation. (This explanation has a "forward reference" in that it assumes an understanding of type expressions that appears later and, thus, this block of bullets must be understood wholistically.)

    * Tokens that are identified as the names of abbreviations have an appearance in syntax that is similar to that of sorts and type constructors. We shall refer to all of these kinds of symbols collectively as type constants when there is no need to make finer distinctions.

    * Type declarations are those expressions in the category <Sign-Decl> that begin with the token type. Type declarations identify term constants with their associated types. Note that the constants for which types can be so declared have a limited syntax. In particular, they should not begin with an uppercase letter or the underscore (`_`) character.

    * Type expressions are constructed, as usual, from type constants, type variables and the arrow type constructor written as ->. Tokens appearing in such expressions are classified as type variables or type constants depending on whether or not they begin with an uppercase letter or the underscore (`_`) character. In understanding the structure of potentially ambiguous type expressions, the following convention is to be used: the application of a type constructor to types is left associative and has higher precedence than the construction of an arrow type; i.e. (tc ty1 ... tyn -> sort) is read as ((...(tc ty1)...tyn) -> sort).

    * All sorts and type constructors that appear in type expressions must be either built-in or defined in the signature or defined in an accumulated signature and should have the arity required of them at the point of use. A sort or type constructor that is used in an accumulated signature and that is not defined there but is defined in a sibling accumulated signature may or may not be flagged as an error; the precise behavior is depended on the order of accumulation that is undefined at the language description level.

    * A requirement for a type expression to be well-formed is that every type constructor and every identifier that names an abbreviation that appears in it must be supplied with a full complement of argument types, i.e. the usage of a type constant must be consistent with its declaration. A well-formed type expression then denotes the type that is obtained by replacing each type abbreviation with the expression corresponding to it as described above.

    * Operator declarations are those expressions in the category <Sign-Decl> that are further characterized by the form

       	<Fixity> <Ids> <SmallInt> '.' 

      Such declarations identify relevant (term) constants as being infix, prefix or postfix operators that are not associative, left associative or right associative and having a specified precedence. Types of constants that are defined as operators must be consistent with their interpretation as such.

    * Exportdef and useonly declarations are expressions in the <Sign-Decl> category that begin with the tokens exportdef and useonly, respectively. exportdef and useonly declarations must pertain to predicate constants only, i.e. constants with a target type o. exportdef declarations identify the relevant constants as ones whose definitions emanating from the module associated with the signature must not change. useonly declarations play a complementary role: these identify predicates that might be used in the module associated with the signature but whose definitions cannot be further refined there. exportdef and useonly declarations can also identify types with the relevant constants. In this case, the type expressions must satisfy all the requirements required of them relative to type declarations of the usual form.

    * The intended effect of use`_`sig declarations is similar to that of accum`_`sig declarations with one change: every exportdef declaration appearing in the signature being included (or accumulated) must first be changed to a useonly declaration of the same constants. Intuitively, use`_`sig declarations serve to identify predicates (and associated constants and kinds) in the signature of a "consumer;" the change in annotation from exportdef to useonly signals that these predicates can be used but must not be redefined or extended in any code possessing the signature. 

    * There must be at most one type, one kind or type abbreviation and one fixity identification per Id. There might be multiple declarations in each category for this Id but all must agree eventually within that category. Also, no predicate should be defined both useonly and exportdef in any given module.

    * Fixity declarations must be for constants defined in the signature. 