#summary Program Structure in Teyjus

= The Structure of Teyjus Programs =

Programming in Lambda Prolog is structured around the definition of modules. In Teyjus, there are three files associated with a module. If the name of the module is <modname> then these files are <modname>.mod, <modname>.sig and <modname>.lp, and they correspond, respectively, to the source code, the signature and the bytecode file generated by the compiler for the module. The user of Teyjus is not concerned with the internal structure of the bytecode file and it suffices for him/her to know merely of its existence. It is necessary, however, to understand the structure and purpose of the signature and source code file in order to produce meaningful Lambda Prolog programs that can be compiled and executed under Teyjus. This chapter presents the structure of these two kinds of objects. Before looking at the syntactic aspects, however, it is useful to understand the intended roles of these two kinds of objects in programming.

Signatures are associated with a module to determine an external view for it. In particular, a signature identifies names of sorts, type constructors, constants and operators and also might indicate that certain predicates are to be used in the module without changes in their definitions or that a fixed definition for these predicates is to be exported from that module. Signatures are eventually employed in two ways: (a) when a module is being compiled, the signature is used to determine whether the module is "living up to its promise" and also to qualify some of the declarations in the module and (b) when some other module imports or accumulates this one, the signature determines what is externally visible and hence plays a role in certifying the module interactions.

Two technical terms are used in the above paragraph to describe possibilities for module interactions: importing and accumulating. We pause briefly to explain these kinds of interactions. Importation is a process by which the globally visible procedures defined in a particular module become dynamically available in solving the bodies of procedures in another module. Note that actual interactions of this kind manifest themselves only at loading and execution time. Modules that interact through importation are in fact compiled separately in Teyjus, with signatures being used to ensure compatibility and to determine load-time actions and run-time interactions. Accumulation, on the other hand, is mainly a compile-time process: it calls for the accretion of the code in other independently defined modules into a new, larger, module. The vision that accumulation is intended to evoke is that of static inlining of code. However, the inlining is not entirely naive. In Lambda Prolog it is possible to scope constant names and procedure definitions over modules. For names, this is achieved via the notion of a local constant: any constant that is not defined in the signature form the module is interpreted as being local. For procedures, this is manifest in the scopes of imports (and also in explicit implication goals). The inlining corresponding to accumulation is to be done in a way that respects scopes. In particular, locals in an accumulated module are to be treated as being distinct even if there is a coincidence in names with the constants in another accumulated module or in the accumulating module. Similarly, imports in an accumulated module have only the code originating in that module as their scope.

The precise way in which signatures fulfill their intended roles is manifest in the notions of matching a module declaration with its signature and of certifying interactions via imports and accumulates. These notions are explained in more detail in this chapter after a presentation of the syntax of signatures and modules supported by Teyjus. 