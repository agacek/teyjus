#summary The Lambda Prolog Abstract Machine

= An Overview of the Virtual Machine Underlying Teyjus =

An integral part of the scheme that has been used for implementing Teyjus is virtual machine that is capable of realizing the operations that arise in typical Lambda Prolog programs efficiently. As with other logic programming languages, unification and backtracking are intrinsic to Lambda Prolog and the Warren Abstract Machine (WAM) provides a basic structure for treating these aspects well. However, an extensive embellishment of this framework is needed for realizing several additional features satisfactorily:

    * The language contains primitives that can alter the name space and the definitions of procedures in the course of execution. This means, in particular, that unification has to pay attention to changing signatures and that the solution to each (sub)goal has to be relativized to the relevant program context.

    * In contrast to other languages, lambda terms are used in Lambda Prolog as _data structures_. A representation must therefore be provided for these terms that permits their structures to be examined and compared in addition to supporting reduction operations efficiently.

    * Higher-order unification is used in an intrinsic way in the language. This operation is conceptually more complex than the unification operation of Prolog and a practical way of supporting it must be found. In doing this, it may sometimes be necessary to delay the solution of unification problems. For this reason, a mechanism must be devised for representing unification problems explicitly.

    * In addition to having a role in determining program correctness, types could be relevant to the dynamic behavior of programs. A scheme must therefore be designed for  reducing the runtime impact of types and this must be augmented by a good mechanism for carrying types along into computatations when this cannot be avoided. 

    * Programming in the language is done relative to modules. In realizing this feature, it is necessary to support certain operations for composing different modules. Moreover, if modularity is to be genuine, a mechanism must be devised for realizing separate compilation. 

Work carried out by Gopalan Nadathur, Bharat Jayaraman and Keehang Kwon culminated in late 1997 in the design of a virtual machine that included devices for treating all these aspects well. The solution to the problem of changing signatures was based on an elegant scheme for tagging constants and variables and using these tags in unification. To realize changing program contexts, a fast method was designed for adding and removing code that is capable also of dealing with backtracking behaviour. The code that needs to be added may sometimes contain global variables and this possibility was dealt with by an adaptation to logic programming of the idea of a closure. To facilitate a sensible representation of lambda terms, an explicit substitution calculus called the _suspension calculus_ was designed and deployed in the low-level steps for manipulating lambda term that are contained in the abstract machine. This abstract machine handled full higher-order unification, an operation that is characterized by its branching behaviour. Techniques were developed for treating such branching and also for compiling unification steps and for prioritizing deterministic parts of the unification computation. In treating types, ideas were introduced for utilizing information available at compile time about their structure to substantially reduce the effort expended at runtime in creating and analyzing types. Finally, towards supporting modular programming, a method was designed for realizing separate compilation with one of the module interaction mechanisms. This mechanism also required the addition and removal of blocks of code. Techniques for dealing with changing program contexts in the core language could be used to implement this aspect. However, these methods had to be embellished with new mechanisms for avoiding redundancy in the added code, something that could only be determined at runtime.