#summary The components of the Teyjus system

=  An Overview of the Teyjus System =

The approach to implementing _Lambda Prolog_ that has been developed in the _Teyjus_ project is the following. First, we have designed an abstract or virtual machine that has an instruction set and supporting structures that can be used to realize all the high-level computations implicit in a _Lambda Prolog_ program. Then we have developed techniques for translating or compiling actual _Lambda Prolog_ programs to instructions that can run on this virtual machine. Now, one might wonder what the benefit is of executing the compiled form of _Lambda Prolog_ programs as opposed to directly interpreting them. Actually several arguments can be extended in support of this approach. To begin with, the construction of this virtual machine has paid close attention to what is needed for _Lambda Prolog_, it also has been designed keeping in mind what is practical to realize in hardware. Thus, it is conceivable that it may be realized in silicon, thereby obviating an interpretation step. More realistically, though, the abstract machine will be emulated in software. Even then, there are benefits. For example, the process of examining and translating a program allows us to notice certain computations that can already be done at compile-time, thereby improving the dynamic behaviour of the program. As another example, translating initially to a congenial target such as the virtual machine instructions allows us to understand the nuances better so that a more difficult subsequent goal of directly generating native code becomes manageable. Finally, the virtual machine can itself have a purpose: it can be treated as an intermediate language to which other similar high-level languages can be translated. Within the _Teyjus_ project, we are actually exploring the possibility of providing such an implementation of the [http://twelf.plparty.org/wiki/Main_Page Twelf] specification language using this approach.


An implementation of Lambda Prolog on stock hardware based on the the present ideas envisages four software subsystems: a compiler, a loader, an emulator for the abstract machine and a user interface. The function of the compiler is to process any given module of Lambda Prolog code, to certify its internal consistency and to ensure that it satisfies a promise determined by an associated signature and, finally, to translate it into a byte code form consisting of a `header' part relevant to realizing module interactions and a `body' containing sequences of instructions that can be run on the abstract machine. The purpose of the loader is to read in byte code files for modules that need to be used, to resolve names and absolute addresses using the information in the header parts of these files and to eventually produce a structure consisting of a block of code together with information for linking this code into a program context when needed. The emulator provides the capability of executing such code after it has been linked. Finally, the user interface allows for a flexibility in the compilation, loading and use of modules in an interactive session.

The Teyjus system embodies all the above components and comprises about 50,000 lines of C code. The functionality outlined above is realized in its entirety in a development environment. Also supported is the use of the compiler on the one hand and the loader and emulator on the other in standalone mode. The system architecture actually makes byte code files fully portable. Thus, Lambda Prolog modules can be distributed in byte code form, to be executed later using only the loader/emulator. Finally, the system includes a disassembler for the purpose of viewing the results of compilation. 
Add your content here.